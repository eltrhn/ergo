"""
ergo as a single file
generated by pre-commit hook
"""
import shlex
import os
import inspect
import sys
from ast import literal_eval
from functools import partial, wraps
from itertools import starmap, chain, zip_longest
from types import SimpleNamespace
from copy import deepcopy


__all__ = 'CLI', 'auto', 'booly', 'errors'

_Null = type(
  '_NullType', (),
  {
    '__bool__': lambda self: False,
    '__repr__': lambda self: '<_Null>',
  }
  )()
VAR_POSITIONAL, KEYWORD_ONLY = inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.KEYWORD_ONLY


def _callable(obj):
    return callable(obj) and obj is not inspect._empty


def convert(hint, val):
    return hint(val) if _callable(hint) else val


def typecast(func):
    def _hint_for(param):
        return func.__annotations__.get(param.name)
    params = inspect.signature(func).parameters.values()
    
    pos = [_hint_for(p) for p in params if p.kind < VAR_POSITIONAL]
    var_pos = [_hint_for(p) for p in params if p.kind == VAR_POSITIONAL]
    pos_defaults = [p.default for p in params if p.kind < VAR_POSITIONAL]
    
    kw = {p.name: _hint_for(p) for p in params if p.kind == KEYWORD_ONLY}
    var_kw = [_hint_for(p) for p in params if p.kind > KEYWORD_ONLY]
    kw_defaults = {p.name: p.default for p in params if p.kind == KEYWORD_ONLY}
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        args_, kwargs_ = [], {}
        arg_iter = iter(args)
        if len(args) > len(pos) and not var_pos:
            func(*args, **kwargs)  # raise TypeError
        args_.extend(starmap(convert, zip(pos, arg_iter)))
        args_.extend(pos_defaults[len(args_):])
        if inspect._empty in args_:
            for idx, (param, hint, passed) in enumerate(zip(params, pos, args_)):
                if passed is not inspect._empty:
                    continue
                try:
                    args_[idx] = convert(hint, kwargs.pop(param.name))
                except KeyError:
                    func(*(i for i in args_ if i is not inspect._empty), **kwargs_)  # raise TypeError
        if var_pos:
            hint = var_pos[0]
            args_.extend(map(hint, arg_iter) if _callable(hint) else arg_iter)
        for name, hint in kw.items():
            try:
                kwargs_[name] = convert(hint, kw[name])
            except KeyError:
                default = kw_defaults[name]
                if default is inspect._empty:
                    func(*args, **kwargs)  # raise TypeError
                kwargs_[name] = default
        if var_kw:
            hint = var_kw[0]
            kwargs_.update({name: convert(hint, val) for name, val in kwargs if name not in kwargs_})
        return func(*args_, **kwargs_)
    return wrapper


def booly(arg):
    comp = arg.lower()
    if comp in ('yes', 'y', 'true', 't', '1'):
        return True
    elif comp in ('no', 'n', 'false', 'f', '0'):
        return False
    else:
        raise ValueError('Could not convert {!r} to boolean'.format(arg))


class auto:
    def __new__(cls, obj, *rest):
        if isinstance(obj, str) and not rest:
            return cls._leval(obj)
        return super().__new__(cls)
    
    def __init__(self, *types):
        self.types = types
        self.negated = False
        
        if not all(isinstance(i, type) for i in self.types):
            raise TypeError("auto() argument '{}' is not a type".format(
              next(i for i in self.types if not isinstance(i, type))
            ))
    
    def __invert__(self):
        self.negated ^= True
        return self
    
    def __call__(self, obj):
        ret = self._leval(obj)
        if self.negated:
            if isinstance(ret, self.types):
                raise TypeError('Did not expect {}-type {!r}'.format(
                  type(ret).__name__,
                  ret
                ))
        elif not isinstance(ret, self.types):
            raise TypeError('Expected {}, got {} {!r}'.format(
              '/'.join(i.__name__ for i in self.types),
              type(ret).__name__,
              ret
            ))
        return ret
    
    @staticmethod
    def _leval(obj):
        try:
            return literal_eval(obj)
        except (SyntaxError, ValueError):
            return obj


class multiton:
    classes = {}
    
    def __init__(self, pos=None, *, kw=False, cls=None):
        self.class_ = cls
        self.kw = kw
        self.pos = pos
    
    def __call__(self, deco_cls):
        cls = self.class_ or deco_cls
        if cls not in self.classes:
            self.classes[cls] = {}
        instances = self.classes[cls]
        
        @wraps(deco_cls)
        def getinstance(*args, **kwargs):
            key = (args[:self.pos], kwargs) if self.kw else args[:self.pos]
            if key not in instances:
                instances[key] = deco_cls(*args, **kwargs)
            return instances[key]
        getinstance.cls = deco_cls
        return getinstance


class ErgoNamespace(SimpleNamespace):
    def __bool__(self):
        return bool(vars(self))
    
    def __contains__(self, name):
        return hasattr(self, name)
    
    def __eq__(self, other):
        return vars(self) == other
    
    def __getitem__(self, name):
        return self.__getattribute__(name)
    
    def __iter__(self):
        yield from vars(self)
    
    @property
    def __(self):
        return SimpleNamespace(
          items=vars(self).items,
          keys=vars(self).keys,
          values=vars(self).values,
          get=vars(self).get,
          pretty=(lambda self, sep='\n', delim=': ':
            sep.join(
              '{}{}{}'.format(k, delim, v)
              for k, v in self.__.items()
            )).__get__(self)
          )

class ClumpGroup(set):
    def successes(self, parsed):
        return {name for c in self if c.verify(parsed) for name in c.member_names}
    
    def failures(self, parsed):
        return ((c.member_names, c.to_eliminate(parsed)) for c in self if not c.verify(parsed))


class _Clump:
    def __init__(self, key, host):
        self.key = key
        self.host = host
        self.members = set()
    
    @property
    def member_names(self):
        return frozenset(i.name for i in self.members)
    
    def add(self, item):
        self.members.add(item)


@multiton()
class And(_Clump):
    def verify(self, parsed):
        # this should contain either no members or all members (latter indicating none were given)
        diff = self.member_names.difference(parsed)
        return not diff or parsed == diff
    
    def to_eliminate(self, parsed):  # received
        return frozenset(self.member_names.intersection(parsed))


@multiton()
class Or(_Clump):
    def verify(self, parsed):
        # this should contain at least 1 member
        return bool(self.member_names.intersection(parsed))
    
    def to_eliminate(self, parsed):  # received
        return frozenset(self.member_names.intersection(parsed))


@multiton()
class Xor(_Clump):
    def verify(self, parsed):
        # this should contain exactly 1 member
        return len(self.member_names.intersection(parsed)) == 1
    
    def to_eliminate(self, parsed):  # not received
        return frozenset(self.member_names.difference(parsed))


VAR_POS = inspect.Parameter.VAR_POSITIONAL


@multiton()
class Entity:
    def __init__(self, func, *, name=None, namespace=None, help=None):
        params = inspect.signature(func).parameters
        has_nsp = bool(namespace)
        first_optional = next((i for i, v in enumerate(params.values()) if v.default is not inspect._empty), sys.maxsize)
        self._namespace = namespace
        self.params = list(params)[has_nsp:]
        self.argcount = sys.maxsize if any(i.kind == VAR_POS for i in params.values()) else len(params) - has_nsp
        self._normalized_params = [
          ('({})'.format(v) if i >= first_optional else v).upper()
          for i, v in enumerate(self.params[:-1])
          ]
        if self.params:
            last = self.params[-1]
            if self.argcount == sys.maxsize:
                self._normalized_params.append('{}...'.format(last).upper())
            else:
                self._normalized_params.append(('({})'.format(last) if len(params) >= first_optional else last).upper())
        self.func, self.callback = func, typecast(func)
        self.help = inspect.cleandoc(func.__doc__ or '' if help is None else help)
        self.brief = next(iter(self.help.split('\n')), '')
        self.identifier = name or func.__name__
        self.name = self.identifier
    
    @property
    def namespace(self):
        return deepcopy(self._namespace)
    
    def __call__(self, *args, **kwargs):
        return self.callback(*args, **kwargs)


@multiton(cls=Entity.cls)
class Flag(Entity.cls):
    def __init__(self, *args, _='-', **kwargs):
        super().__init__(*args, **kwargs)
        self.name = self.identifier.replace('_', _)
        self.short = None
    
    @property
    def args(self):
        return ' ' + ' '.join(self._normalized_params) if self.params else ''
    
    def __str__(self):
        if self.short is None:
            return '[--{}{}]'.format(self.name, self.args)
        return '[-{} | --{}{}]'.format(self.short, self.name, self.args)


@multiton(cls=Entity.cls)
class Arg(Entity.cls):
    def __init__(self, cb, repeat_count, **kwargs):
        super().__init__(cb, **kwargs)
        self.name = self.identifier
        self.repcount = repeat_count
    
    def __str__(self):
        return '{}({})'.format(self.identifier, '...' if self.repcount is Ellipsis else self.repcount)

class ErgoException(Exception):
    def __init__(self, msg, **kwargs):
        self.details = ErgoNamespace(**kwargs)
        super().__init__(msg)


class ANDError(ErgoException):
    pass


class ORError(ErgoException):
    pass


class XORError(ErgoException):
    pass


class RequirementError(ErgoException):
    pass


_FILE = os.path.basename(sys.argv[0])


class HelperMixin:
    @property
    def all_commands(self):
        return (*self.commands, *(name for g in self._groups for name in g.commands))
    
    @property
    def all_flags(self):
        return (*self.flags.values(), *(entity for g in self._groups for entity in g.flags.values()))
    
    @property
    def all_args(self):
        return map(self.getarg, self.args)
    
    @property
    def usage_info(self):
        return '{}{} {} {}'.format(
          _FILE,
          str(self),
          ' '.join(map(str, self.all_flags)),
          ' '.join(map(str, self.all_args)),
          )
    
    @property
    def help_info(self):
        return '\n'.join(
          '{}\n{}'.format(
            label.upper(),
            '\n'.join({
              '\t{: <15} {}'.format(i.name, i.brief)
              for i in getattr(self, 'all_' + label)
            }),
          )
          for label in ('args', 'flags')
        )
    
    def format_help(self, usage=True, commands=True, help=True):
        built = ['', self.desc, ''] if self.desc else ['']
        if usage:
            built.append('usage: {}'.format(self.usage_info))
        if commands and self.commands:
            built.append('Commands: {}'.format(','.join(map(str, self.all_commands))))
        if help and (usage or commands):
            built.append('')
        if help:
            built.append(self.help_info)
        return '\n'.join(built)
    
    def print_help(self, usage=True, commands=True, help=True):
        print(self.format_help(usage, commands, help), end='\n\n')
    
    def error(self, exc=None, help=True):
        self.print_help(commands=help, help=help)
        if exc is None:
            raise SystemExit
        raise SystemExit(exc if str(exc) else type(exc))
    
    def cli_help(self, name=None):
        if name is None:
            self.error()
        
        entity = self.get(name)
        if entity is None:
            print('No helpable entity named', repr(name))
            raise SystemExit
        
        try:
            short = getattr(entity, 'short', '')
            aliases = ', '.join(map(repr, (k for k, v in self._aliases.items() if v == name and k != short)))
        except AttributeError:
            aliases = ''
        
        if aliases:
            print('', entity, 'Aliases: {}\n'.format(aliases), entity.help, sep='\n', end='\n\n')
        else:
            print('', entity, entity.help, sep='\n', end='\n\n')
        raise SystemExit


class _Handler:
    def __init__(self):
        self.arg_map = {}
        self.commands = {}
        self.flags = {}
        self._aliases = {}
        self._defaults = {}
        
        self.args = []
        self._last_arg_consumes = False
        
        self._and = ClumpGroup()
        self._or = ClumpGroup()
        self._xor = ClumpGroup()
        
        self._required = set()
    
    def __repr__(self):
        quote = "'" if hasattr(self, 'name') else ''
        return '<{}{s}{q}{}{q}>'.format(
          self.__class__.__name__,
          getattr(self, 'name', ''),
          s=' ' if hasattr(self, 'name') else '',
          q=quote,
          )
    
    @property
    def defaults(self):
        return ErgoNamespace(**self._defaults)
    
    @property
    def parent_and(self):
        return self._and
    
    @property
    def parent_or(self):
        return self._or
    
    @property
    def parent_xor(self):
        return self._xor
    
    @property
    def entity_names(self):
        return set(chain(self.arg_map, self.commands, self.flags))
    
    def dealias(self, name):
        return self._aliases.get(name, name)
    
    def remove(self, obj):
        name = obj.identifier if isinstance(obj, Entity.cls) else obj
        if name in self.arg_map:
            del self.arg_map[name]
            self.args = list(filter(name.__eq__, self.args))
        else:
            try:
                del next(filter(lambda c: name in c, (self.commands, self.flags)))[name]
            except StopIteration:
                raise KeyError('No such entity: {}'.format(obj))
        self._aliases = {k: v for k, v in self._aliases.items() if v != name}
    
    def get(self, name):
        for func in (self.getarg, self.getflag, self.getcmd):
            try:
                return func(name)
            except KeyError:
                pass
        return None
    
    def getarg(self, name):
        try:
            return self.arg_map[name]
        except KeyError:
            return self._aliases[self.arg_map[name]]
    
    def getflag(self, name):
        try:
            return self.flags[name]
        except KeyError:
            return self.flags[self._aliases[name]]
    
    def getcmd(self, name):
        try:
            return self.commands[name]
        except KeyError:
            return self.commands[self._aliases[name]]
    
    def hasflag(self, name):
        return name in self.flags or self._aliases.get(name, _Null) in self.flags
    
    def hascmd(self, name):
        return name in self.commands or self._aliases.get(name, _Null) in self.commands
    
    def hasany(self, name):
        return self.hasflag(name) or self.hascmd(name) or name in self.arg_map or self._aliases.get(name, _Null) in self.arg_map
    
    def _clump(self, obj, AND, OR, XOR):
        if AND is not _Null:
            self._and.add(And(AND, self))
            And(AND, self).add(obj)
        if OR is not _Null:
            self._or.add(Or(OR, self))
            Or(OR, self).add(obj)
        if XOR is not _Null:
            self._xor.add(Xor(XOR, self))
            Xor(XOR, self).add(obj)
    
    def enforce_clumps(self, parsed, groups=None):
        elim = {lbl.upper(): getattr(self, 'parent_'+lbl).successes(parsed) for lbl in ('and', 'or', 'xor')}
        if groups is not None:
            g_clumps = {lbl: {groups.get(i) for i in set(successes).intersection(groups)} for lbl, successes in elim.items()}
            zipped = {lbl: (elim[lbl], {name for g in groups for name in g.entity_names}) for lbl, groups in g_clumps.items()}
            elim = {lbl: grp.union(success) for lbl, (success, grp) in zipped.items()}
        
        def extract_names(collection):
            if groups is None:
                return map(repr, collection)
            return (
              '[{}]'.format(
                ', '.join(map(repr, groups[n].entity_names))
                )
              if n in groups
              else repr(n)
              for n in collection
              )
        
        err_details = {
          'AND_SUC': elim['AND'],
          'OR_SUC': elim['OR'],
          'XOR_SUC': elim['XOR'],
          'parsed': parsed,
          'groups': groups,
          'handler': repr(self)
          }
        
        for all_failed, received in self._and.failures(parsed):
            # AND failure == member of an AND clump that was not given
            # an AND failure is okay if it's in a satisfied OR clump (i.e. there's at least one other OR in its clump that was given)
            # or if it's in a satisfied XOR clump (i.e. exactly one other XOR in its clump was given)
            not_exempt = (all_failed - received) - elim['OR'] - elim['XOR']
            if not_exempt:
                raise ANDError(
                  'Expected all of the following flags/arguments: {}\n(Got {})'.format(
                      ', '.join(extract_names(all_failed)),
                      ', '.join(extract_names(received)) or 'none'
                    ),
                  **err_details,
                  failed=all_failed, eliminating=received, not_exempt=not_exempt
                  )
        
        for all_failed, received in self._or.failures(parsed):
            # OR failure == member of an OR clump where none were given
            # an OR failure is okay if it's in a satisfied XOR clump (i.e. exactly one other XOR in its clump was given)
            not_exempt = (all_failed - received) - elim['XOR']
            if not_exempt:
                raise ORError(
                  'Expected at least one of the following flags/arguments: {}\n(Got none)'.format(
                      ', '.join(extract_names(all_failed))
                    ),
                  **err_details,
                  failed=all_failed, eliminating=received, not_exempt=not_exempt
                  )
        
        for all_failed, not_received in self._xor.failures(parsed):
            # XOR failure == member of an XOR clump that was given alongside at least one other
            # an XOR failure is okay if it satisfies an AND clump (i.e. all other ANDs in its clump were given)
            ####################################################################################
            # XXX: SHOULD it be okay if it satisfies an OR clump? What about if it's required? #
            # That is: should this actually say `- elim['AND'] - elim['OR'] - self._required`? #
            ####################################################################################
            not_exempt = (all_failed - not_received) - elim['AND']
            if len(not_exempt) > 1:
                raise XORError(
                  'Expected no more than one of the following flags/arguments: {}\n(Got {})'.format(
                      ', '.join(extract_names(all_failed)),
                      ', '.join(extract_names(all_failed-not_received))
                    ),
                  **err_details,
                  failed=all_failed, eliminating=not_received, not_exempt=not_exempt
                  )
        
        return True
    
    def clump(self, *, AND=_Null, OR=_Null, XOR=_Null):
        def inner(cb):
            entity = Entity(cb.func if isinstance(cb, Entity.cls) else cb)
            self._clump(entity, AND, OR, XOR)
            return entity
        return inner
    
    def arg(self, n=1, *, required=False, default=_Null, namespace=None, help=None):
        """
        n: number of times this arg should be received consecutively; ... for infinite
        Expected kwargs: _ (str), help (str)
        """
        def inner(cb):
            repeat_count = n
            entity = Arg(cb, n, namespace=namespace, help=help)
            self.arg_map[entity.name] = entity
            if required:
                self._required.add(entity.name)
            if repeat_count is Ellipsis:
                self._last_arg_consumes = True
                repeat_count = 1
            if default is not _Null:
                self._defaults[entity.name] = default
            self.args.extend([entity.name] * repeat_count)
            return entity
        return inner
    
    def flag(self, dest=None, short=_Null, *, aliases=(), default=_Null, required=False, namespace=None, help=None, _='-'):
        def inner(cb):
            entity = Flag(cb, namespace=namespace, name=dest, help=help, _=_)
            # filter out '<lambda>'
            if cb.__name__.isidentifier() and dest is not None:
                self._aliases[cb.__name__] = entity.name
            if short is not None:  # _Null == default; None == none
                try:
                    entity.short = short or next(s for s in entity.name if s.isalnum() and s not in self._aliases)
                except StopIteration:
                    pass
                else:
                    self._aliases[entity.short] = entity.name
            if default is not _Null:
                self._defaults[entity.identifier] = default
            if required:
                self._required.add(entity.name)
            for alias in aliases:
                self._aliases[alias] = entity.name
            self.flags[entity.name] = entity
            return entity
        return inner
    
    def command(self, name, desc='', *args, AND=_Null, OR=_Null, XOR=_Null, from_cli=None, aliases=(), _='-', **kwargs):
        if from_cli is None:
            subcmd = Command(*args, **kwargs, name=name, desc=desc, parent=self)
        else:
            subcmd = Command.from_cli(from_cli, self, name)
        visual_name = name.replace('_', _)
        for alias in aliases:
            self._aliases[alias] = visual_name
        self._clump(subcmd, AND, OR, XOR)
        self.commands[visual_name] = subcmd
        return subcmd


class ParserBase(_Handler, HelperMixin):
    def __init__(self, desc='', flag_prefix='-', *, systemexit=True, no_help=False):
        self.desc = desc
        self.flag_prefix = flag_prefix
        self.long_prefix = 2 * flag_prefix
        self.systemexit = systemexit
        self._groups = set()
        super().__init__()
        if not flag_prefix:
            raise ValueError('Flag prefix cannot be empty')
        if not no_help:
            self.flag(
              'help',
              help="Prints help and exits\nIf given valid NAME, displays that entity's help"
              )(lambda name=None: self.cli_help(name))
    
    def __setattr__(self, name, val):
        if not isinstance(val, Group):
            return object.__setattr__(self, name, val)
        
        if name in vars(self):
            raise ValueError('Group name already in use for this cli: ' + name)
        if val._required:
            self._required.add(name)
        
        self._groups.add(val)
        self._clump(val, val._and, val._or, val._xor)
        
        SubHandler.__init__(val, self, name)
        object.__setattr__(self, name, val)
    
    def dealias(self, name):
        try:
            return next(g.dealias(name) for g in self._groups if g.hasany(name))
        except StopIteration:
            return super().dealias(name)
    
    def remove(self, obj):
        name = obj.name if isinstance(obj, Entity.cls) else obj
        for g in self._groups:
            try:
                return g.remove(name)
            except KeyError:
                pass
        return super().remove(name)
    
    def get(self, name):
        try:
            return next(g.get(name) for g in self._groups if g.hasany(name))
        except StopIteration:
            return super().get(name)
    
    def getarg(self, name):
        try:
            return next(g.getarg(name) for g in self._groups if name in g.arg_map)
        except StopIteration:
            return super().getarg(name)
    
    def getflag(self, name):
        try:
            return next(g.getflag(name) for g in self._groups if g.hasflag(name))
        except StopIteration:
            return super().getflag(name)
    
    def getcmd(self, name):
        try:
            return next(g.getcmd(name) for g in self._groups if g.hascmd(name))
        except StopIteration:
            return super().getcmd(name)
    
    def hasflag(self, name):
        return super().hasflag(name) or any(g.hasflag(name) for g in self._groups)
    
    def hascmd(self, name):
        return super().hascmd(name) or any(g.hascmd(name) for g in self._groups)
    
    def hasany(self, name):
        return super().hasany(name) or self._aliases.get(name, _Null) in self.arg_map
    
    def enforce_clumps(self, parsed):
        p = set(parsed) | {next((g.name for g in self._groups if g.hasany(i)), None) for i in parsed} - {None}
        return (
          super().enforce_clumps(p, {g.name: g for g in self._groups})
          and
          all(g.enforce_clumps(parsed) for g in self._groups if g.name in p)
          )
    
    def _put_nsp(self, namespaces, entity):
        return entity if entity.namespace is None else partial(
          entity,
          namespaces.setdefault(
            entity.name,
            ErgoNamespace(**entity.namespace)
            ),
          )
    
    def _extract_flargs(self, inp, strict=False):
        flags = []
        args = []
        skip = 0
        command = None
        allow_flags = True
        for idx, value in enumerate(inp, 1):
            if skip > 0:
                skip -= 1
                continue
            if value == '--':
                allow_flags = False
                continue
            
            if (not allow_flags) or (not value.startswith(self.flag_prefix) or value in (self.flag_prefix, self.long_prefix)):
                if self.hascmd(value):
                    command = (value, idx)
                    break
                args.append(value)
                if strict and len(args) > len(self.args):
                    raise TypeError('Too many positional arguments (expected {}, got {})'.format(
                      len(self.args), len(args)
                      ))
            elif allow_flags:
                if '=' in value:
                    name, arg = value.lstrip(self.flag_prefix).split('=', 1)
                    if self.hasflag(name):
                        flags.append((self.dealias(name), [arg] if arg else []))
                    elif strict:
                        raise TypeError("Unknown flag `{}'".format(value.split('=')[0]))
                    continue
                
                if value.startswith(self.long_prefix):
                    if self.hasflag(value.lstrip(self.flag_prefix)):  # long
                        skip = self.getflag(value.lstrip(self.flag_prefix)).argcount
                        next_pos = next((i for i, v in enumerate(inp[idx:]) if v.startswith(self.flag_prefix)), len(inp))
                        if next_pos < skip:
                            skip = next_pos
                        flags.append((self.dealias(value.lstrip(self.flag_prefix)), inp[idx:skip+idx]))
                    elif strict:
                        raise TypeError("Unknown flag `{}'".format(value))
                    continue
                
                for name in value[1:]:  # short
                    if self.hasflag(name):
                        skip = self.getflag(name).argcount
                        next_pos = next((i for i, v in enumerate(inp[idx:]) if v.startswith(self.flag_prefix)), len(inp))
                        if next_pos < skip:
                            skip = next_pos
                        flags.append((self.dealias(name), inp[idx:skip+idx]))
                    elif strict:
                        raise TypeError("Unknown flag `{}{}'".format(value[0], name))
        
        return flags, args, command
    
    def do_parse(self, inp=None, strict=False):
        parsed = {}
        namespaces = {}
        flags, positionals, command = self._extract_flargs(inp, strict)
        prep = partial(self._put_nsp, namespaces)
        
        for flag, args in flags:
            if self.hasflag(flag):
                entity = self.getflag(flag)
                parsed[entity.identifier] = prep(entity)(*args)
        
        if self._last_arg_consumes and len(positionals) > len(self.args):
            zipped_args = zip_longest(map(self.getarg, self.args), positionals, fillvalue=self.getarg(self.args[-1]))
        else:
            zipped_args = zip(map(self.getarg, self.args), positionals)
        
        for entity, value in zipped_args:
            parsed[entity.identifier] = prep(entity)(value)
        
        if command is not None:
            value, idx = command
            parsed[self._aliases.get(value, value)] = self.getcmd(value).do_parse(inp[idx:], strict)
        
        self.enforce_clumps(parsed)
        final = {**self._defaults, **{name: value for g in self._groups for name, value in g._defaults.items()}, **parsed}
        nsp = ErgoNamespace(**final)
        
        if self._required.difference(nsp):
            raise RequirementError('Expected the following required arguments: {}\nGot {}'.format(
              ", ".join(map(repr, self._required)),
              ", ".join(map(repr, self._required.intersection(nsp))) or 'none'
              )
            )
        
        return nsp
    
    def parse(self, inp=None, *, systemexit=None, strict=False):
        if inp is None:
            inp = sys.argv[1:]
        if isinstance(inp, str):
            inp = shlex.split(inp)
        try:
            return self.do_parse(list(inp), strict)  # inp.copy()
        except Exception as e:
            if systemexit is None and self.systemexit or systemexit:
                self.error(e, help=False)
            raise
        except SystemExit:
            if systemexit is None and self.systemexit or systemexit:
                raise


class SubHandler(_Handler):
    def __init__(self, parent, name):
        if not name:
            raise ValueError('Sub-handler name cannot be empty')
        self.name = name
        self.parent = parent
        super().__init__()
    
    @property
    def parent_and(self):
        return ClumpGroup(self._aliases.get(i, i) for i in chain(self._and, self.parent.parent_and))
    
    @property
    def parent_or(self):
        return ClumpGroup(self._aliases.get(i, i) for i in chain(self._or, self.parent.parent_or))
    
    @property
    def parent_xor(self):
        return ClumpGroup(self._aliases.get(i, i) for i in chain(self._xor, self.parent.parent_xor))


class Group(SubHandler):
    def __init__(self, *, required=False, AND=_Null, OR=_Null, XOR=_Null):
        """
        CLI later calls `SubHandler.__init__(Group(), self, name)` in its __setattr__()
        (All instance attributes are overridden by this)
        """
        self._required = required
        self._and = AND
        self._or = OR
        self._xor = XOR
    
    def arg(self, n=1, **kwargs):
        """
        n: number of times this arg should be received consecutively; pass ... for infinite
        Expected kwargs: _ (str), help (str)
        """
        def inner(cb):
            entity = Arg(cb, n, namespace=kwargs.get('namespace'), help=kwargs.get('help'))
            self.arg_map[entity.name] = entity
            if kwargs.get('required'):
                self._required.add(entity.name)
            return self.parent.arg(n, **kwargs)(entity.func)
        return inner
    
    def flag(self, dest=None, short=_Null, **kwargs):
        def inner(cb):
            entity = Flag(cb, namespace=kwargs.get('namespace'), name=dest, help=kwargs.get('help'), _=kwargs.get('_', '-'))
            if dest is not None:
                self._aliases[cb.__name__] = entity.name
            if short is not None:  # _Null == default; None == none
                try:
                    entity.short = short or next(s for s in entity.name if s.isalnum() and s not in self._aliases)
                except StopIteration:
                    pass
                else:
                    self._aliases[entity.short] = entity.name
            if kwargs.get('default', _Null) is not _Null:  # could be `in` but we don't want them using _Null
                self._defaults[entity.identifier] = kwargs['default']
            if kwargs.get('required'):
                self._required.add(entity.name)
            self.flags[entity.name] = entity
            return self.parent.flag(dest, short, **kwargs)(entity.func)
        return inner


class Command(SubHandler, ParserBase):
    def __init__(self, flag_prefix='-', *, parent, name, desc):
        SubHandler.__init__(self, parent, name)
        ParserBase.__init__(self, desc, flag_prefix)
    
    def __str__(self):
        return ' {}'.format(self.name)
    
    @property
    def help(self):
        return self.format_help()
    
    @classmethod
    def from_cli(cls, cli, parent, name):
        inst = cls(cli.flag_prefix, parent=parent, name=name, desc=cli.desc)
        vars(inst).update(cli.__dict__)
        return inst


class CLI(ParserBase):    
    def __str__(self):
        return ''


class Simpleton:
    _ = '-'
    flag_prefix = '-'
    short_flags = True
    no_help = False
    used = False
    
    def __init__(self, func, cli=None):
        self.cli = cli or CLI(no_help=self.no_help, flag_prefix=self.flag_prefix)
        # Fossilize these so if they're changed on the class it doesn't modify this instance
        self._ = self._
        self.flag_prefix = self.flag_prefix
        self.short_flags = self.short_flags
        self.no_help = self.no_help
        
        if self.used:
            raise ValueError('Cannot have more than one function per simple command/CLI')
        self.used = True
        
        self._consuming = False
        self.commands = {}
        
        self._callback = func
        self._params = inspect.signature(func).parameters.values()
        self.cli.desc = func.__doc__ or ''
        
        pos = [i for i in self._params if i.kind <= inspect.Parameter.VAR_POSITIONAL]
        flags = [i for i in self._params if i.kind == inspect.Parameter.KEYWORD_ONLY]
        
        self._consuming = pos and pos[-1].kind == inspect.Parameter.VAR_POSITIONAL
        self._add_flargs(self.cli, pos, flags)
    
    def __call__(self, *args, **kwargs):
        return self._callback(*args, **kwargs)
    
    @staticmethod
    def _null_check(val):
        return val is _Null or val is inspect._empty
    
    @classmethod
    def no_top_level(cls, help=''):
        simple = cls(lambda: None)
        simple.cli.desc = help
        return simple
    
    def _add_flargs(self, cli, pos, flags):
        for arg in pos:
            if arg.kind == inspect.Parameter.VAR_POSITIONAL:
                def __hidden(arg):
                    def __inner(nsp, value):
                        nsp.accum.append(convert(arg.annotation, value))
                        return nsp.accum
                    __inner.__name__ = arg.name
                    return __inner
                cli.arg(
                  Ellipsis,
                  namespace={'accum': []},
                  required=False,
                  default=_Null if self._null_check(arg.default) else arg.default,
                )(__hidden(arg))
            else:
                def __hidden(arg):
                    def __inner(value):
                        return convert(arg.annotation, value)
                    __inner.__name__ = arg.name
                    return __inner
                cli.arg(
                  required=self._null_check(arg.default),
                  default=_Null if self._null_check(arg.default) else arg.default,
                )(__hidden(arg))
        
        for flag in flags:
            def __hidden(flag):
                def __inner(value):
                    return convert(flag.annotation, value)
                __inner.__name__ = flag.name
                return __inner
            cli.flag(
              short=_Null if self.short_flags else None,
              default=_Null if self._null_check(flag.default) else flag.default,
              _=self._
            )(__hidden(flag))
    
    def command(self, func):
        self.commands[func.__name__] = cmd = Simpleton(func, self.cli.command(func.__name__, _=self._))
        cmd.no_help = self.no_help
        cmd.short_flags = self.short_flags
        cmd._ = self._
        return cmd
    
    def call(self, **flags):
        args = []
        commands = []
        for name, val in flags.copy().items():
            if isinstance(val, ErgoNamespace):
                # This used to be:
                # self.commands[name].call(**dict(flags.pop(name).__.items()))
                # But commands being run before the main callback was bad
                # So now it's deferred until the `for cmd, flargs in commands:` loop
                commands.append((self.commands[name], dict(flags.pop(name).__.items())))
            elif name in self._params:
                args.append(flags.pop(name))
        
        args = [
          flags.pop(p.name, ())
            if p.kind == inspect.Parameter.VAR_POSITIONAL
          else flags.pop(p.name)
            if p.name in flags or p.default is inspect._empty
          else p.default
          for p in self._params
          if p.kind <= inspect.Parameter.VAR_POSITIONAL
          ]
        
        if self._consuming:
            args.extend(args.pop(-1))
        
        ret = self._callback(*args, **flags)
        
        for cmd, flargs in commands:
            cmd.call(**flargs)
        return ret
    
    def run(self, inp=None):
        return self.call(**dict(self.cli.parse(inp).__.items()))
    
    def search(self, inp):
        if inp is None:
            inp = sys.argv[1:]
        if isinstance(inp, str):
            inp = shlex.split(inp)
        if not isinstance(self.cli, CLI):
            try:
                idx = next(
                  i for i, v in enumerate(inp)
                  if v == self._callback.__name__
                  and not
                  (inp[i-1].startswith(self.cli.flag_prefix) or '=' in inp[i-1].lstrip(self.cli.flag_prefix))
                  )
            except StopIteration:
                raise IndexError('command invocation {!r} not found in input'.format(self._callback.__name__))
            inp = inp[idx:]
        return self.run(inp)


# sys.modules[__name__] = Simpleton


errors = SimpleNamespace(ANDError=ANDError, ORError=ORError, XORError=XORError, RequirementError=RequirementError)
